name: 'Handle Infrastructure Deployment'

# The workflow should only trigger when indirectly invoked
on:
  workflow_call:
    inputs:
      environment_name:
        required: true
        type: string
      run_terraform_apply:
        type: boolean
        default: false
    outputs:
      deploy_mode:
        value: ${{ jobs.deploy-infrastructure.outputs.deploy_mode }}

env:
  aws_region: "eu-west-1"
  aws_oidc_role_arn: "arn:aws:iam::339713083458:role/GitHubOIDCkununuAccessRole"

jobs:
  deploy-infrastructure:
    name: Deploy
    runs-on: ubuntu-latest
    steps:
      # Don't allow re-running deploys to a production environment
      - name: Fail on repeated run
        if: ${{ contains('["production"]', inputs.environment_name ) && github.run_attempt != 1 }}
        run: |
          printf "## Infrastructure\n" >> $GITHUB_STEP_SUMMARY
          printf "Deploy was *prohibited* as this is a rerun\n\n" >> $GITHUB_STEP_SUMMARY
          printf "To deploy to the _%q_ environment, trigger a new workflow\n" '${{ inputs.environment_name }}' >> $GITHUB_STEP_SUMMARY
          false # fail at this point

      # replace any of these with GitHub Actions variables and use var.* instead of env.*
      # for example replace var.aws_region instea of env.aws_region
      - id: set-common-variables
        name: Set common variables
        run: |
          case ${{inputs.environment_name }} in
            development)
            aws_account_id=471112841961
            ;;
            test)
            aws_account_id=637423657022
            ;;
            staging)
            aws_account_id=891376915771
            ;;
            production)
            aws_account_id=654654185437
            ;;
            esac

          echo "aws_account_id=$aws_account_id" >> "$GITHUB_ENV"
          echo "aws_role_arn=arn:aws:iam::$aws_account_id:role/${{ github.event.repository.name }}-repo" >> "$GITHUB_ENV"

      # i would like to have this step as a reusable workflow but we cant parse credentials between jobs see https://github.com/orgs/community/discussions/66044
      - id: assume-GitHubOIDCkununuAccessRole-role
        name: get GitHubOIDCkununuAccessRole AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.aws_region }}
          role-to-assume: ${{ env.aws_oidc_role_arn }}
          role-session-name: ${{ github.actor_id }}-${{ github.run_id }}
          mask-aws-account-id: false # masking would affect unrelated steps if configured
          disable-retry: true

      - id: assume-repo-role
        name: Configure repo specific AWS Creentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region:  ${{ env.aws_region }}
          role-to-assume: ${{ env.aws_role_arn }}
          role-session-name: ${{ github.actor_id }}-${{ github.run_id }}
          role-chaining: true
          mask-aws-account-id: false # masking would affect unrelated steps if configured
          disable-retry: true

      - name: Verify AWS access
        id: verify-aws-access
        shell: bash
        run: |
          aws sts get-caller-identity --query Arn --output text

      - name: Check out
        uses: actions/checkout@v4

      - name: Read Terraform version
        run: |
          echo "terraform_version=$(cat .terraform-version)" >> $GITHUB_ENV
          printf "## Infrastructure\n" >> $GITHUB_STEP_SUMMARY
          echo "Selected Terraform version $(cat .terraform-version)" >> $GITHUB_STEP_SUMMARY

      - name: Install Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false #TODO: do we need this?
          terraform_version: ${{ env.terraform_version }}

      - id: terraform-init
        name: Terraform init
        # This step does not require the output from load-terraform-data-ssm
        run: >-
          terraform -chdir="$(git rev-parse --show-toplevel)/terraform" init -no-color -var-file="../environments/${{ inputs.environment_name }}.tfvars" -backend-config="../environments/${{ inputs.environment_name }}.tfbackend"

      - id: plan-terraform
        name: Terraform plan
        run: |
          printf 0 > /tmp/terraform_plan_status
          terraform -chdir="$(git rev-parse --show-toplevel)/terraform" plan -no-color -detailed-exitcode -input=false -lock-timeout=60s -var-file=<(cat environments/${{ inputs.environment_name }}.tfvars environments/common.tfvars) -out=terraform.tfplan || printf "%d" "$?" > /tmp/terraform_plan_status
          # Use result to decide what happens next

          if [ "$( cat /tmp/terraform_plan_status )" = 1 ]; then
            printf ":red_circle: Planning failed\n" >> $GITHUB_STEP_SUMMARY
            printf "\n\n---\n\n" >> $GITHUB_STEP_SUMMARY
            printf "See the detailed GitHub Action diagnostics for more details.\n" >> $GITHUB_STEP_SUMMARY
          fi

          # If the infrastructure is up to date there is no need to run a Terraform apply
          cat /tmp/terraform_plan_status | grep -qE '^[02]$' # verify Terraform status; fail on error

          printf "apply_required=%s\n" "$( if [ "$( cat /tmp/terraform_plan_status )" = 2 ] ; then echo -n true; else echo -n false; fi )" | tee --append "$GITHUB_OUTPUT"

          if [ "$( cat /tmp/terraform_plan_status )" = 0 ]; then
            printf ":white_circle: Infrastructure is up to date\n" >> $GITHUB_STEP_SUMMARY
          fi

          # emit saved error, if relevant
          ( exit "$( if [ "$( cat /tmp/terraform_plan_status )" = 1 ] ; then echo -n 1; else echo -n 0; fi  )" )

      - id: apply-terraform
        name: Terraform apply
        # Only run a Terraform apply if there are changes to make
        if: >-
          (github.event_name == 'workflow_dispatch' &&
          inputs.run_terraform_apply &&
          inputs.environment_name != 'production') ||
          (github.event_name == 'push' && github.ref == 'refs/heads/main')
        run: |
          apply_status=0
          # apply Terraform and save error status
          terraform -chdir="$(git rev-parse --show-toplevel)/terraform" apply -no-color -auto-approve -lock-timeout=60s -no-color terraform.tfplan > /tmp/terraform_apply_output || apply_status=$0
          # Record what happened
          cat /tmp/terraform_apply_output
          if [ "$apply_status" = 0 ] && grep -q '^Apply complete!' /tmp/terraform_apply_output; then
            printf ":green_circle: *%s*\n" "$( grep  '^Apply complete! Resources: ' /tmp/terraform_apply_output )">> $GITHUB_STEP_SUMMARY
          else
            printf ":red_circle: *%s*\n\n" "Infrastructure change(s) failed.">> $GITHUB_STEP_SUMMARY
            printf "<details open>\n<summary>Terraform apply output</summary>\n\n\`\`\`\n" >> $GITHUB_STEP_SUMMARY
            printf "%s\n" "$( cat /tmp/terraform_apply_output )" >> $GITHUB_STEP_SUMMARY
            printf "\`\`\`\n</details>\n\n" >> $GITHUB_STEP_SUMMARY
            # Print out errors provided there were not too many of them.
            if [ "$( grep -c Error: /tmp/terraform_apply_output )" -lt 5 ]; then
              printf "\n\n---\n\n" >> $GITHUB_STEP_SUMMARY
              grep Error: /tmp/terraform_apply_output >> $GITHUB_STEP_SUMMARY
            fi
            printf "\n\n---\n\n" >> $GITHUB_STEP_SUMMARY
            printf "See the detailed GitHub Action diagnostics for more details.\n" >> $GITHUB_STEP_SUMMARY
          fi
          ( exit $apply_status ) # emit saved error, if any

      - id: save-terraform-outputs
        name: Save Terraform outputs
        run: |
          # Save outputs (provided they are set, are plain values, and are not sensitive)
          terraform -chdir="$(git rev-parse --show-toplevel)/terraform" output -json |\
            jq 'to_entries[] | select(.value.sensitive == false) | select(.value.type as $type | ["bool","string","number"]|any(. == $type))' |\
            jq 'select(.value.value != null)' |\
            jq -r ' .key + "=" + (.value.value|tostring)' |\
            tee --append "$GITHUB_OUTPUT"
    outputs:
      deploy_mode: ${{ steps.save-terraform-outputs.outputs.deploy_mode }}
